<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Annotation Agreement Demo</title>
  <style>
    :root {
      --green: #c8f7c5;
      --yellow: #fef3c7;
      --red: #fecaca;
      --black: #000;
    }
    body { font-family: Arial, Helvetica, sans-serif; margin: 0; height: 100vh; display: flex; }
    #main { flex: 1.6; padding: 20px; overflow: auto; background: #fff; }
    #sidebar { flex: 0.8; padding: 16px; border-left: 1px solid #ddd; box-sizing: border-box; }
    h2 { margin-top: 0; }
    #policyWrapper { 
      display:flex; 
      align-items:start; 
      gap:8px; 
      flex-direction:row; 
      margin-top:10px; 
    }
    #policyContainer { 
      flex:1; 
      padding: 12px; 
      border: 1px solid #eee; 
      border-radius: 6px; 
      background: #fff; 
    }
    .highlight { cursor: pointer; border-radius: 2px; }
    .green { background: var(--green); }
    .yellow { background: var(--yellow); }
    .red { background: var(--red); }
    .legend { margin: 10px 0; display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .legend > div { display:flex; gap:6px; align-items:center; }
    .swatch { width:14px; height:14px; border-radius:2px; border:1px solid #ccc; display:inline-block; }
    .swatch.green { background: var(--green); }
    .swatch.yellow { background: var(--yellow); }
    .swatch.red { background: var(--red); }
    .stat { margin-bottom: 8px; }
  </style>
</head>
<body>
  <div id="main">
    <h2>Annotation Agreement Demo</h2>
    <input type="file" id="fileInput" accept=".json" />
    <div class="legend">
      <div><span class="swatch green"></span> All annotators agree</div>
      <div><span class="swatch yellow"></span> Some annotated (partial)</div>
      <div><span class="swatch red"></span> Annotators disagree</div>
    </div>
    <div id="stats" class="stat">Load a JSON file to see stats.</div>
    <div id="policyWrapper">
      <div id="policyContainer"></div>
      </div>
    </div>
  </div>

  <div id="sidebar">
    <h3>Hovered segment details</h3>
    <div id="details">Hover a highlighted region to see which annotator labeled it and the label(s).</div>
  </div>

  <script>
    function parseHTMLBody(htmlString) {
      try {
        const doc = new DOMParser().parseFromString(htmlString, 'text/html');
        return doc.body ? doc.body.innerHTML : htmlString;
      } catch (e) {
        return htmlString;
      }
    }

    function buildTextNodeIndex(root) {
      const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, null);
      const nodes = [];
      let node;
      let idx = 0;
      while ((node = walker.nextNode())) {
        const len = node.nodeValue ? node.nodeValue.length : 0;
        nodes.push({ node: node, start: idx, end: idx + len });
        idx += len;
      }
      return { nodes, totalLength: idx };
    }

    function findNodeForOffset(nodesIndex, offset) {
      if (offset === nodesIndex.totalLength) {
        const last = nodesIndex.nodes[nodesIndex.nodes.length - 1];
        return { node: last.node, local: last.node.nodeValue.length };
      }
      for (let n of nodesIndex.nodes) {
        if (offset >= n.start && offset < n.end) {
          return { node: n.node, local: offset - n.start };
        }
      }
      return null;
    }

    function computeColorAndDetails(coveringAnns) {
      if (!coveringAnns || coveringAnns.length === 0) return { className: null, details: '' };
      
      // --- Color logic (unchanged) ---
      const labels = [...new Set(coveringAnns.map(a => a.label))];
      const users = [...new Set(coveringAnns.map(a => a.user))];
      let className = 'yellow';
      if (labels.length === 1 && users.length > 1) className = 'green';
      else if (labels.length > 1) className = 'red';

      // --- MODIFIED: New details logic to group by label ---
      const orderedLabels = [
        "Sender", "Subject", "Information Type", "Recipient", 
        "Aim", "Condition", "Modalities", "Consequence"
      ];
      const labelsToUsers = {};
      coveringAnns.forEach(ann => {
        if (!ann.label) return; // Skip annotations without a label
        if (!labelsToUsers[ann.label]) {
          labelsToUsers[ann.label] = new Set(); // Use a Set to automatically handle duplicate users
        }
        labelsToUsers[ann.label].add(ann.user);
      });

      const detailsArr = [];
      const processedLabels = new Set();

      // Process labels in the specified order
      orderedLabels.forEach(label => {
        if (labelsToUsers[label]) {
          let section = `<b>${label}</b><br>`;
          section += [...labelsToUsers[label]].map(user => `&nbsp;&nbsp;- Annotator ${user}`).join('<br>');
          detailsArr.push(section);
          processedLabels.add(label);
        }
      });

      // Process any other labels not in the ordered list
      Object.keys(labelsToUsers).forEach(label => {
        if (!processedLabels.has(label)) {
          let section = `<b>${label}</b><br>`;
          section += [...labelsToUsers[label]].map(user => `&nbsp;&nbsp;- Annotator ${user}`).join('<br>');
          detailsArr.push(section);
        }
      });
      
      const details = detailsArr.join('<br><br>');

      return { className, details };
    }

    function processTask(task) {
      const container = document.getElementById('policyContainer');
      container.innerHTML = '';

      const rawHTML = (task.data && task.data.text) ? task.data.text : (task.file_upload || '');
      const bodyHTML = parseHTMLBody(rawHTML);
      container.innerHTML = bodyHTML;

      const annSpans = [];
      (task.annotations || []).forEach(annObj => {
        (annObj.result || []).forEach(r => {
          if (r.value && r.value.globalOffsets) {
            annSpans.push({
              start: Number(r.value.globalOffsets.start),
              end: Number(r.value.globalOffsets.end),
              user: annObj.completed_by,
              label: Array.isArray(r.value.labels) ? r.value.labels[0] : (r.value.labels || null),
              text: r.value.text || ''
            });
          }
        });
      });

      if (annSpans.length === 0) {
        document.getElementById('stats').innerText = 'No annotation spans found.';
        return;
      }

      let nodesIndex = buildTextNodeIndex(container);
      const totalLen = nodesIndex.totalLength;
      const breakSet = new Set([0, totalLen]);
      annSpans.forEach(s => {
        if (s.start >= 0 && s.start <= totalLen) breakSet.add(s.start);
        if (s.end >= 0 && s.end <= totalLen) breakSet.add(s.end);
      });
      const breaks = [...breakSet].sort((a,b)=>a-b);

      const segments = [];
      for (let i=0;i<breaks.length-1;i++){
        const s=breaks[i], e=breaks[i+1];
        if (s===e) continue;
        const covering = annSpans.filter(a=>a.start<=s && a.end>=e);
        segments.push({start:s,end:e,covering});
      }

      const segmentsToWrap = segments.filter(seg=>seg.covering.length>0)
                                     .sort((a,b)=>b.start-a.start);

      segmentsToWrap.forEach(seg=>{
        nodesIndex = buildTextNodeIndex(container);
        const curTotal = nodesIndex.totalLength;
        const segStart = Math.min(seg.start, curTotal);
        const segEnd = Math.min(seg.end, curTotal);
        const startPos = findNodeForOffset(nodesIndex, segStart);
        const endPos = findNodeForOffset(nodesIndex, segEnd);
        if (!startPos || !endPos) return;
        try {
          const range=document.createRange();
          range.setStart(startPos.node,startPos.local);
          range.setEnd(endPos.node,endPos.local);
          const {className,details}=computeColorAndDetails(seg.covering);
          const frag=range.extractContents();
          const span=document.createElement('span');
          span.className='highlight '+className;
          span.dataset.details=details;
          span.appendChild(frag);
          range.insertNode(span);
        } catch(e){console.warn('wrap failed',seg,e);}
      });

      // --- MODIFIED: Use innerHTML to render formatted details ---
      container.querySelectorAll('.highlight').forEach(el=>{
        el.addEventListener('mouseenter',()=>{
          document.getElementById('details').innerHTML = el.dataset.details || 'No labels';
        });
      });
      
      const grouped = {};
      annSpans.forEach(a=>{
        const k=`${a.start}-${a.end}`;
        if(!grouped[k]) grouped[k]=[];
        grouped[k].push(a);
      });
      const fullAgree = Object.values(grouped).filter(list=>{
        const labels=[...new Set(list.map(x=>x.label))];
        const users=[...new Set(list.map(x=>x.user))];
        return labels.length===1 && users.length>1;
      }).length;

      document.getElementById('stats').innerHTML =
        `<strong>Distinct spans:</strong> ${Object.keys(grouped).length} &nbsp; | &nbsp; ` +
        `<strong>Full agreements:</strong> ${fullAgree}`;
    }

    document.getElementById('fileInput').addEventListener('change',ev=>{
      const f=ev.target.files[0];
      if(!f) return;
      const reader=new FileReader();
      reader.onload=e=>{
        try{
          const json=JSON.parse(e.target.result);
          const task=Array.isArray(json)?json[0]:json;
          processTask(task);
        }catch(err){alert('Failed to parse JSON: '+err.message);}
      };
      reader.readAsText(f);
    });
  </script>
</body>
</html>